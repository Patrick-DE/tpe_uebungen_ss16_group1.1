Aufgabe 1: Threads - Theorie 40 Punkte
Beschreiben und benennen Sie die Probleme, die durch die Anwesenheit von mehreren Threads entstehen können.
Veranschaulichen Sie außerdem jedes der genannten Probleme anhand eines Beispielprogramms (Die Kommentare in diesen Programmen durfen auf Deutsch verfasst werden).

- Durch Multithreading läuft der Programmablauf asynchronous ab. Falls ein Thread Daten schreibt kann es vorkommen, 
dass zur gleichen Zeit ein anderer Thread die gleichen Vatiable beschreibt. Dies könnte eine Inkonsistenz aufweisen.
synchronized(object)
{
    // statement to be synchronized
}

Safety Hazards - das Programm verhält sich in Anwesenheit mehrerer Threads nicht mehr korrekt.
- race condition
occurs when two or more threads can access shared data and they try to change it at the same time. 
Because the thread scheduling algorithm can swap between threads at any time, you don't know the 
order in which the threads will attempt to access the shared data. Therefore, the result of the change 
in data is dependent on the thread scheduling algorithm, i.e. both threads are "racing" to access/change the data.
if (x == 5) // The "Check"
{
   y = x * 2; // The "Act"

   // If another thread changed x in between "if (x == 5)" and "y = x * 2" above,
   // y will not be equal to 10.
}

// Obtain lock for x
if (x == 5)
{
   y = x * 2; // Now, nothing can change x until the lock is released. 
              // Therefore y = 10
}
// release lock for x


Liveness Hazards - Probleme bei denen ein Programm mitmehreren Threads in einen Zustand gerät, bei dem es keine Fortschritte mehr machen kann.
- Deadlock
public class Deadlock {
    static class Friend {
        private final String name;
        public Friend(String name) {
            this.name = name;
        }
        public String getName() {
            return this.name;
        }
        public synchronized void bow(Friend bower) {
            System.out.format("%s: %s"
                + "  has bowed to me!%n", 
                this.name, bower.getName());
            bower.bowBack(this);
        }
        public synchronized void bowBack(Friend bower) {
            System.out.format("%s: %s"
                + " has bowed back to me!%n",
                this.name, bower.getName());
        }
    }

    public static void main(String[] args) {
        final Friend alphonse =
            new Friend("Alphonse");
        final Friend gaston =
            new Friend("Gaston");
        new Thread(new Runnable() {
            public void run() { alphonse.bow(gaston); }
        }).start();
        new Thread(new Runnable() {
            public void run() { gaston.bow(alphonse); }
        }).start();
    }
}

- Livelock
A thread often acts in response to the action of another thread. If the other thread's action is 
also a response to the action of another thread, then livelock may result. As with deadlock, 
livelocked threads are unable to make further progress. However, the threads are not blocked —
 they are simply too busy responding to each other to resume work. This is comparable to two people attempting 
to pass each other in a corridor: Alphonse moves to his left to let Gaston pass, while Gaston moves to his right 
to let Alphonse pass. Seeing that they are still blocking each other, Alphone moves to his right, while Gaston moves to his left. They're still blocking each other, so...

- Starvation(Aushungern)
Starvation describes a situation where a thread is unable to gain regular access to shared resources and is 
unable to make progress. This happens when shared resources are made unavailable for long periods by "greedy" threads. 
For example, suppose an object provides a synchronized method that often takes a long time to return. 
If one thread invokes this method frequently, other threads that also need frequent synchronized access to 
the same object will often be blocked.

Performance-Hazards
Ein-Programm-das-zwar-korrektfunkUoniert,-die-Performance-ist-jedoch-trotz-mehrererThreads-schlecht.-